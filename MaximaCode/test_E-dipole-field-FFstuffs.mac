load("E-dipole-field")$
load("waveforms")$

test_pts:[xyz_coords_to_spherical([1,0,0])]$
mu:1$
epsilon:1$
c:1/sqrt(mu*epsilon)$
fc:1/2$ /* gaussian pulse center frequency */
d:1$ /* dipole length 1 */
sigma:d_gpulse_sigma_fc(fc)$
/* As chosed by the python code for -60 dB at f=1/2 cutoff */
m: rationalize(1.3387351236498068)$


/* q (charge) is the integral of current, with an initial value of 0 at t=0 */
q_expr:ev(gpulse) - ev(gpulse, t:0)$
i_expr:ev(d_gpulse)$

/*
q(t):= if t > 0 then (ev(q_expr)) else (0)$
i(t):= if t > 0 then (ev(i_expr)) else (0)$
*/

/* Setting the functions to zero for t < 0 would require the use of a dirac delta
   at t=0 for i(t), and the derivative of a dirac delta for diff(i, t) which is
   undefined. Leaving the finite values for t < 0 assumes that we started with a
   finite amount of charge at t = -inf, and that the system has been operational
   since t = -inf.

   Setting the driving fuctions to 0 for t < 0, ignoring the dirac deltas may or
   may not be a good idea but is harder to implement analytically.

   If instead nothing is done, there will be finite but small, aparantly
   anti-causal fields existing at points where t - r/c < 0. Where t - r/c > 0
   the fields should be exactly correct regardless of the treatment. Perhaps it
   would be better to set E = 0 at all the points where t - r/c < 0.
*/

q(t):=ev(q_expr)$
i(t):=ev(i_expr)$

E_fun_(t, r, theta, phi):= if (t-r/c) >= 0 then (ev(E)) else ([0,0,0])$
E_fun(t, sphcoords):=apply(E_fun_, append([t], sphcoords))$
H_fun_(t, r, theta, phi):= if (t-r/c) >= 0 then (ev(H)) else ([0,0,0])$
H_fun(t, sphcoords):=apply(H_fun_, append([t], sphcoords))$


dt:1/75 $ runtime: 20$ no_time_pts: ceiling(runtime/dt)$ 
time_pts: linspace(0, runtime, no_time_pts+1)$
E_vals:map(lambda([pt], makelist(bfloat(E_fun(t, pt)), t, time_pts)), test_pts), fpprec:24$
H_vals:map(lambda([pt], makelist(bfloat(H_fun(t, pt)), t, time_pts)), test_pts), fpprec:24$
scatter1 (xy) := ([n: length (xy)],
                 plot2d ([[parametric, '(xy[fix(i)][1]),
                          '(xy[fix(i)][2]), [i, 1, n], [nticks, n]]],
                        [gnuplot_curve_styles, ["with lines", 3]]))$

scatter2 (x,y) := ([n: length (x)],
                 plot2d ([[parametric, '(x[fix(i)]), '(y[fix(i)]),
                          [i, 1, n], [nticks, n]]], 
                        [gnuplot_curve_styles, ["with lines", 3]]))$

E_th:makelist(x[2]/d,x,E_vals[1])$
