load("BasisFunction")$
load("CommonSimplexStuff")$
remove(".", commutative)$
sublam_e:lambda([bf],vectorsimp(ev(bf, lam2:1-lam1)))$
c_g1:lambda([bf], coeff(bf, grad(lam1)))$
s_c_g1:lambda([bf], c_g1(sublam_e(bf)))$
W1:onef_efs_R1[1]$
W2:onef_efs_G1[1]$
W_edgefuns:to_var_list(transpose(matrix(onef_efs_R1, onef_efs_G1)))$
/* List of edge BFs, organised W_edgefuns[edge_no][edge_bf_no] */
W_edgefuns:makelist(part(W_edgefuns, i), i, 1, length(W_edgefuns))$
W1_e:s_c_g1(W1)$
W2_e:s_c_g1(W2)$

G:onef_efs_R1[1]$
G1:(3*lam1-1)*G$
G2:(3*lam2-1)*G$
G1_e:s_c_g1(G1)$
G2_e:s_c_g1(G2)$
kill(matgen_p, matgen_m)$
matgen_p[i,j]:=concat('W,i)*concat('G,j)$
matgen_m[i,j]:=concat('G,i)*concat('G,j)$
load("FlatTet")$
tet_verts:get_verts(tets[1], mesh_verts)$
edges:map(lambda([nodes], tet_verts[nodes[2]] - tet_verts[nodes[1]]), local_edgenodes)$

match_fun:[(a1*x + a2*y + a3*z + a4),
           (a5*x + a6*y + a7*z + a8),
           (a9*x + a10*y + a11*z +a12)]$

/* Graglia's "first" order edge Bf's i.t.o. Webb's first-order edge BFs
I.e. to represent G1 in webb BFs, go [W1, W2].[G1_to_W].

Calculated by substituting lam2 = 1-lam1 into the BFs and using the monomial
representation of th e resulting scalar univariate polynomial to calculate the
transform. Must code this still ;) */

G1_to_W:[1/2, 3/2]$
G2_to_W:[1/2, -3/2]$
G_to_W:[G1_to_W, G2_to_W]$

/* Interpolation points where the respective G edge-BFs attain unity value on
edge 1 */
interp_pts_e1:[[2/3, 1/3, 0, 0], [1/3, 2/3, 0, 0]]$
/* Equivalent interp points for edges 1 thru 6 */
interp_pts:map(lambda([nodes], map(
      lambda([pt], __tmp:[0,0,0,0], __tmp[nodes[1]]:pt[1],
      __tmp[nodes[2]]:pt[2], __tmp), interp_pts_e1)),
  local_edgenodes)$
xyzs:xyz(tet_verts)$
/* Function to be matched i.t.o. simplex coords */
match_fun_l:subst([x=xyzs[1], y=xyzs[2], z=xyzs[3]], ''match_fun)$
/* Values of match_fun at the interpolation points for each respective edge */
interp_vals:makelist(map(lambda([pt], subst(makelist(
          concat(lam, j)=pt[j],j,1,4), ''match_fun_l)), interp_pts[i]),
  i, 1, 6)$

/* Tangential projection of match_fun values at interpolation points onto the
respective edges */
interp_vals_edge_proj:makelist(map(lambda([ptval],edges[i].ptval),
    interp_vals[i]), i, 1, 6)$

/* Get the equivalent Webb DOFs by taking the Graglia DOFs on each edge,
multiplying them by the Webb to Graglia conversion vector and then adding them
all together to get the final Webb edge DOF vector. */
edge_dofs:makelist(interp_vals_edge_proj[i].G_to_W, i, 1, 6)$

lams:lam_det(simplex_tetmat(tet_verts))$
grd_lams:ev(express(map("grad", lams)), diff)$
/* Reconstruct, and, voila, reconstruced == match_fun */
reconstructed:lreduce("+", makelist(W_edgefuns[i].edge_dofs[i], i, 1, 6))$
reconstructed:ev(expand(reconstructed), grd_lam:grd_lams, lam:lams)$