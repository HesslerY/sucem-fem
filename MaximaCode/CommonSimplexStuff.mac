/* Remember to load("vect"); before use */
load("eigen");
scalefactors([x,y,z])$ /* Set up Cartesian coordinate system */

local_facenodes:[[1,2,3],
                 [1,2,4],
                 [1,3,4],
                 [2,3,4]]$
local_face_opposite_nodes:[4,3,2,1]$
local_faceedges:[[1,4,2],
                 [1,5,3],
                 [2,6,3],
                 [4,6,5]]$
local_edgenodes:[[1,2],
                 [1,3],
                 [1,4],
                 [2,3],
                 [2,4],
                 [3,4]]$

                             
simplex_tetmat (tet_verts) :=
  /* Return the simplex coefficient matrix

  [[1, x1, y1, z1],
   [1, x2, y2, z2],
   [1, x3, y3, z3],
   [1, x4, y4, z3]]

  with x1 referring to the x-coordinate of the first simplex vertex.

    inputs:

   tet_verts -- List of tetrahedron's vertex co-ordinates
    
  */
  block (local (coord_mat),
     coord_mat [i,j] := tet_verts[i][j],
     addcol (columnvector ([1,1,1,1]), genmatrix (coord_mat, 4, 3)))$

lam_detmats(tetmat):=
  block(local (lam_mat),
    for i:1 thru 4 do
                     (lam_mat[i]:copymatrix(tetmat),
                      lam_mat[i][i]:[1,x,y,z]),
    listarray(lam_mat)
       )$

lam_det(tetmat):=
  block([detmats, dets],
    detmats:lam_detmats(tetmat),
        dets:maplist(determinant, detmats),
    fullratsimp(dets/determinant(tetmat))
       )$
xyz(tet_verts):=makelist(concat(lam, i),i,1,4).tet_verts$

/* This function produces the same result as lam_det, but it gets broken
  when the "vect" package is imported, since it redefines the . operator
*/
lam_in(tetmat):=block([dot_commutative,lm],
  noncommutative_dot_enter(),
  lm:fullratsimp(invert(transpose(tetmat)).[1,x,y,z]),
  noncommutative_dot_exit,
  makelist(lm[i][1],i,1,length(lm)))$

el_lam(tet_verts):=fullratsimp(lam_det(simplex_tetmat(tet_verts)))$

el_lambdas(tets, mesh_verts):=
  map(lambda([tet], el_lam(get_verts(tet, mesh_verts))), tets)$

el_lam_sublist(tv):=block([lams:lam_in(simplex_tetmat(tv))],
  makelist(concat('lam,i)=lams[i], i,1,length(lams)))$

el_grd_lam_sublist(tv):=block(
  [grd_lams:ev(express(map("grad",lam_in(simplex_tetmat(tv)))),diff)],
  makelist(grad(concat('lam,i))=grd_lams[i], i,1,length(grd_lams)))$


ev_lam(lam, xyz):=subst([x=xyz[1],y=xyz[2],z=xyz[3]], lam)$

pt_in_tet(tet_verts, pt):=is(
  equal(lreduce("+", abs(ev_lam(el_lam(tet_verts), pt))), 1))$

lams:[]$
 
for i:0 thru 1 step 1/3
  do (for j:0 thru 1-i step 1/3
        do (for k:0 thru 1-i-j step 1/3
              do (l:1-i-j-k,lams:cons([i,j,k,l], lams))))$

tri_lams:[[],[],[],[]]$
for i:0 thru 1 step 1/3
  do (for j:0 thru 1-i step 1/3
              do (k:1-i-j,
                tri_lams[1]:cons([i,j,k,0], tri_lams[1]),
                tri_lams[2]:cons([i,j,0,k], tri_lams[2]),
                tri_lams[3]:cons([i,0,j,k], tri_lams[3]),
                tri_lams[4]:cons([0,i,j,k], tri_lams[4])))$

row_to_list(matrow):=map(lambda([i], matrow[i]), makelist(i,i,1,length(matrow)))$
col_to_list(matcol):=map(lambda([i], matcol[i][1]), makelist(i,i,1,length(matcol)))$
get_verts(nodes, mesh_verts):=makelist(mesh_verts[i], i, nodes)$
get_edge_vec(edgenodes, mesh_verts):=block([verts:get_verts(edgenodes, mesh_verts)],
  verts[2]-verts[1])$

get_outward_normals(tet_verts):=block([lams:el_lam(tet_verts), gr_lams],
  gr_lams:ev(express(map("grad", lams)), diff),
  makelist(block([grl:-gr_lams[i]],grl/sqrt(inprod(grl,grl))),
    i, local_face_opposite_nodes)
  )$

tri_area(tri_verts):=apply(lambda([a,b,c], block(
      [ab:b-a, ac:c-a], sqrt(express(ab.ab*ac.ac - (ab.ac)^2))/2)), tri_verts)$

