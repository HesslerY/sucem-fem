/* Implementing the E and H fields for an electric dipole as in Haus and Melcher
   S12.2, PP 543-548
*/

load("pdiff")$
kill(A,E,H, r, theta, phi, t, epsilon, mu, d, x, y, z, r, i, q, t, c)$
declare([A, E, H], nonscalar)$
depends([A,E,H], [r, theta, phi, t])$
declare([Phi, mu, epsilon, d, x, y, z, r, i, q, t, c], scalar)$
/* scalefactors([x,y,z])$ */ /* Set up Cartesian coordinate system */
assume(r>=0)$
assume(sin(theta) >= 0)$
scalefactors([[r*sin(theta)*cos(phi),r*sin(theta)*sin(phi),r*cos(theta)],r,theta,phi])$
/*r:sqrt(x^2+y^2+z^2)$ */
/*depends([r], [x,y,z])$ */
A_rect:[0,0,mu*d*i(t-r/c)/(4*%pi*r)]$
A:mu*d/4/%pi*i(t-r/c)/r*[cos(theta), - sin(theta), 0]$
H:fullratsimp(ev(express(curl(A))/mu, diff))$
Phi:d/4/%pi/epsilon*(q(t-r/c)/r^2 + pderivop(q,1)(t-r/c)/c/r)*cos(theta)$
E:fullratsimp(ev(subst([pderivop(i,1)=pderivop(q,2), i=pderivop(q,1)],
      -express(grad(Phi)) - diff(A,t)), diff))$

/* r: sqrt(x^2+y^2+z^2)$
theta: acos(z/sqrt(x^2+y^2+z^2))$ 
phi: atan(y/x)$

cart_to_spherical(cv):=block([xformed:[sqrt(cv[1]^2+cv[2]^2+cv[3]^2),
  atan(cv[2]/cv[1]),
  acos(cv[3]/sqrt(cv[1]^2+cv[2]^2+cv[3]^2))]
  ],
  subst(
    [x=r*sin(theta)*cos(phi), y=r*sin(theta)*sin(phi), z=r*cos(phi)], xformed))$
*/