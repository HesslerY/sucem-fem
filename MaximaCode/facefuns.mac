F(p,i):= block([tau:fix(p/3)],
  if (i > tau) then (throw("Function undefined for i > fix(p,i)")),
  if i < tau then return((lam1*lam2*lam3)^i*lam1*lam2*(lam1-lam2)^(p-3*i-2)),
  if mod(p,3) = 0 then ((lam1*lam2*lam3)^tau)
  else (if mod(p,3)=1 then ((lam1*lam2*lam3)^tau*(lam1-lam2))
    else (lam1*lam2*lam3)^tau*lam1*lam2))$

F_triplets(p,i):=block([triplet:[F(p,i)], tau:fix(p/3), trip_bound],
  if (i < tau) or (mod(p,3) # 0) then(
    trip_bound: if (mod(p,3) = 1) and (i = tau) then (2) else (3),
    for j:2 thru trip_bound do (triplet:append(
        triplet, [sublis([lam1=lam2,lam2=lam3,lam3=lam1],triplet[j-1])]))),
  triplet)$
  
R_face(p):=block(
  [i, sigma:fix((p-1)/3), triplet:[[],[],[]], funs:[]],
  for i:0 thru sigma do
  (if i < sigma or mod(p,3) = 0 then 
    (triplet[1]:F(p,i)*grad(lam3),
      for j:2 thru 3 do (triplet[j]:sublis([lam1=lam2,lam2=lam3,lam3=lam1],triplet[j-1])))
      else
      (if mod(p,3) = 1 then 
        (triplet:[(lam1*lam2*lam3)^i*((lam1-lam2)*grad(lam3)+(lam2-lam3)*grad(lam1)+(lam3-lam1)*grad(lam2))])
        else /* mod(p,3) = 2 */
        (triplet:[(lam1*lam2*lam3)^i*(-2*lam1*lam2*grad(lam3)+lam2*lam3*grad(lam1)+lam3*lam1*grad(lam2))],
         triplet:append( triplet, [sublis([lam1=lam2,lam2=lam3,lam3=lam1],triplet[1])] ))),
     funs:append(funs,[triplet])),
   funs)$

G_face(p):=block([i_max:fix((p+1)/3)-1, triplets:[]],
  for i:0 thru i_max do (
    triplets:append(triplets, [map("grad", F_triplets(p+1,i+1))])),
  triplets)$  