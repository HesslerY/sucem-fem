"""
Proxy flat lists of data as a read-only list of objects without memory overhead

Given lists of attributes:

attr1 = [obj0_attr1, obj1_attr1, ... objn_attr1]
attr2 = [obj0_attr2, obj1_attr2, ... objn_attr2],

a proxy list and object represents the data as:

proxyList[n] -> proxyItem, i.e.
proxyList[n].attr1 -> attr1[n]
proxyList[n].attr2 -> attr2[n]

Module defs
===========

ItemClassFactory
  Generate a custom ProxyItemClass

Module Classes
==============

ProxyList
  Emulate the read-only semantics of a python list for proxied items

ProxyItemClass
  A meta-class(?) generated by ItemClassFactory for insertion into a ProxyList

Basic Usage
===========

Initialisation
--------------
::

  >>> import NewCode.ProxyList as ProxyList
  >>> attr1 = ['obj0_attr1', 'obj1_attr1', 'obj2_attr1']
  >>> attr2 = ['obj0_attr2', 'obj1_attr2', 'obj2_attr2']
  >>> attrs = {'attr1': attr1, 'attr2': attr2}
  >>> ProxyItemClass = ProxyList.ItemClassFactory(attrs, 'ProxyItemClass')
  >>> proxyItem = ProxyItemClass(attrs)
  >>> proxyList = ProxyList.ProxyList(proxyItem)


Access a single item
--------------------
::

  >>> proxyList[0].attr1
  'obj0_attr1'


Loop over all items
-------------------
::

  >>> for item in proxyList:
  ...   print item.attr1
  ... 
  obj0_attr1
  obj1_attr1
  obj2_attr1

Loop over a slice
-----------------
::

  >>> for item in proxyList[0:2]:
  ...   print item.attr2
  ... 
  obj0_attr2
  obj1_attr2

Limitations
===========

Currently the list and object attributes are read-only.

While it looks like there is a list of proxyItems, there is only one proxy
object that returns the n'th item from the list. For instance

"""


def ItemClassFactory(attrs, clsname):
    """
    Return a custom ProxyItemClass based on a user specified attribute list

    The generated class defines properties for each of the attributes in attrs
    to look up values stored in the lists that are being proxied.
    
    Arguments
    =========

    attrs (list) -- list of object attribute names
    clsname (string) -- name of the generated class


    """
    
    getsrc_template = """
@property
def %s(self):
    return self._%s[self.index]
"""
    class ProxyItem(object):
        """
        Class Attributes
        ================

        proxy_attrs -- List of proxied attributes
        """
        
        for attr in attrs:
            exec(compile(getsrc_template % (attr,attr),
                         '<'+clsname+' attribute '+attr+' getter method>',
                         'exec'))

        def __init__(self, attrs=None, *names, **kwargs):
            """

            Initialise the ProxyItem(s) with values stored in lists
            
            Arguments
            ==========
            
            attrs (dict)
            
              Each dict key is the string name of an attrubute, and each dict
              value is a list containing the ordered list of values for each
              attribute. I.e. attrs['attr1'] = [attr1_val0, attr1_val1, ...,
              attr1_valn], where attr1_val0 is the value of attr1 for the first
              element in the Proxylist

              
            """
              
            self.index = 0
            self.numberof = len(attrs.values()[0])
            for val in attrs.values():
                assert(len(val) == self.numberof)
            if attrs:
                for attr, value in attrs.iteritems():
                    setattr(self, '_'+attr, value)
            super(ProxyItem, self).__init__(attrs=attrs,*names,**kwargs)

        def __iter__(self):
            """
            This method should _only_ be called if a someone asked for an
            iterator of a slice. If an iterator over the whole collection is
            requested, the ProxyList.ProxyList class will generate the
            iterator. It can also be called if the ProxyList class is
            subclassed to return non-slice ranges through atrributes.
            """
            try:
                indices = xrange(*self.index.indices(self.numberof))
            except AttributeError:
                indices = self.index
            for i in indices:
                self.index = i
                yield self

        def __len__(self):
            """
            This length function will be called when the len() is requested
            under the same circumstances as the __iter__ method above. E.g.

            proxyslice = ProxyListInstance[0:3]
            len(proxyslice)
            """
            an_attr = self.proxy_attrs[0]
            return len(getattr(self, '_'+an_attr)[self.index])

        def list_repr(self, partial=False):
            """
            Return the lists that form the backing store of the PorxyItem in a dict.
            """
            list_repr = {}
            for attr in self.proxy_attrs:
                try: list_repr[attr] = getattr(self, '_'+attr)
                except AttributeError:
                    if not partial: raise
            return list_repr

    ProxyItem.__name__ = clsname
    # proxy_attrs is the list of attributes that are proxied
    try:
        ProxyItem.proxy_attrs = tuple(attrs.keys())
    except AttributeError:
        ProxyItem.proxy_attrs = tuple(attrs)
    if hasattr(ProxyItem, 'clsname') or hasattr(ProxyItem, 'attr') \
       or hasattr(ProxyItem, 'attr'):
        raise Exception("I was under the impression that these attributes should not exist")
    # Delete unnecesary class attributes
    # del ProxyItem.clsname
    # del ProxyItem.attrs
    #del ProxyItem.attr
    return ProxyItem

class ProxyList(object):

    def __init__(self, entity, *names, **kwargs):
        self.entity = entity
        self.numberof = entity.numberof
        self.bounds = self.numberof - 1
        super(ProxyList, self).__init__(entity, *names, **kwargs)

    def __getitem__(self, index):
        self.entity.index = index
        return self.entity

    def __len__(self):
        return self.numberof

    def __iter__(self):
        for i in xrange(self.numberof):
            self.entity.index = i
            yield self.entity

    def list_repr(self, *names, **kwargs):
        """
        Return the data lists that back the ProxyItem in a dict.

        This method only calls the method of the same name in the entity.
        """
        return self.entity.list_repr(*names, **kwargs)

def memoize_last(args=None):
    """
    Memoize the last return value of ProxyItem methods taking into account the index

    Arguments
    =========

    args
      should have a value of None, 'one', or 'many'. None is used for methods
      that take no arguments, 'one' for methods that take one argument, or
      'many' for methods that take several (unimplemented).

    """
    memo_map = {None: memoize_last_noargs,
                'one': memoize_last_onearg,
                'many': memoize_last_manyargs,
                }
    try:
        return memo_map[args]
    except KeyError:
        raise ValueError, "args should be None, 'one' or 'many'"

def memoize_last_manyargs(func):
    raise NotImplemented, "ProxyList memoization for multi-argument methods not implemented"

class memoize_last_base(object):
    def __init__(self,func):
        self.func = func
        self.last = None

    def __get__(self, instance, cls=None):
        self.instance = instance
        return self

class memoize_last_noargs(memoize_last_base):
    def __call__(self):
        # Account for seperate instances, since the actual memoize instance is
        # created at class definition time, not object initialisation
        if self.last == (self.instance.index, self.instance):
            return self.cached
        else:
            value = self.cached = self.func(self.instance)
            self.last = (self.instance.index, self.instance)
            return value
        
class memoize_last_onearg(memoize_last_base):
    def __call__(self, arg): 
        # Account for seperate instances, since the actual memoize instance is
        # created at class definition time, not object initialisation
        if self.last == (self.instance.index, self.instance, arg):
            return self.cached
        else:
            value = self.cached = self.func(self.instance, arg)
            self.last = (self.instance.index, self.instance,arg)
            return value
       
    
