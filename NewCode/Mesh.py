from __future__ import division
"""
Provide a mesh class and its contained mesh element classes

A mesh is made up of the containing Mesh object, and the various mesh elements
that are contained. This mesh class deals with:

* tetrahedrons
* triangles
* edges

which are all defined in terms of mesh nodes.

Module defs
===========

MeshItemClassFactory
  Generate a custom ProxyListItem class for use as a mesh element/face/edge

Module Classes
==============

Mesh
  Container for geometric elements that make up a mesh

ProxyElements/Faces/Edges
  ProxyList class for mesh elements/faces/edges

Element
  ProxyItemClass based tetrahedral mesh element class


"""
from numpy import array, zeros, int32, alltrue, sort, linalg, isscalar
import numpy as N
from scipy.linalg import norm
import scipy
#
# Local imports
#
import Coordinates
import ProxyList
from Utilities import Struct

class MeshBase(object):
    """
    Container for geometric elements that make up a mesh

    Methods
    =======

    __init__
      Initialise the mesh from lists of element, face, edge and node data

    Attributes
    ==========
    
    nodes
      Array of node coordinates

    edges
      ProxyList of Edge objects.

    faces
      ProxyList of Face objects.

    elements
      ProxyList of Element objects.

    Generated Classes
    =================

    The Edge and Face classes are generated by calls to MeshItemClassFactory.

    Attributes
    ----------

    Edge and Face both define:

    nodes
      The global node indices that define the edge/face

    nodeCoords
      n-row x 3 col array containing the node coordinates

    Face defines:

    edges
      List of global edge indices of the face's three edges.

    """

    acceptableMeshEntities = ('ElementNodes',
                              'ElementEdges',
                              'ElementFaces',
                              'ElementConnect2Elem',
                              'ElementConnect2Face',
                              'FaceNodes',
                              'FaceEdges',
                              'FaceConnect2Elem',
                              'EdgeConnect2Elem',
                              'EdgeNodes',
                              'Nodes',
                              'FemmeshFilename',
                              'FemmeshDir',
                              )
    
    localCoordLen = 4
    def __init__(self, meshEntities):
        """
        Arguments
        =========
        
        meshEntities A dict containing the mesh geometry elements.  The keys
        are defined by the class attribute acceptableMeshEntities.  Generally
        all need to be present, however 'FaceEdges' is currently calculated,
        and should not be passed.
                   
        """
        # If FaceEdges is to be passed in meshEntities, code should be written
        # (and tests) to not calculate it.

        # Insert the keys from meshEntities as object attributes
        for key in self.acceptableMeshEntities:
            if key in meshEntities: setattr(self, key, meshEntities[key])
            else: setattr(self, key, None)

        for el in self.ElementNodes:
            assert(alltrue(sort(el) == el)), \
                                    "Element node numbers should be sorted in ascending order"
        for face in self.FaceNodes:
            assert(alltrue(sort(face) == face)), \
                                      "Face node numbers should be sorted in ascending order"
        for edge in self.EdgeNodes:
            assert(edge[1] > edge[0]), "Edge node numbers should be sorted in assert order"
            
        self.noElements = len(self.ElementNodes)
        self.noFaces = len(self.FaceNodes)
        self.noEdges = len(self.EdgeNodes)
        self.noNodes = len(self.Nodes)

        self.nodes = self.Nodes         # Just to keep the notations consistent
        self.elements = ProxyElements(Element({'facenos': self.ElementFaces,
                                               'edgenos': self.ElementEdges,
                                               'nodes': self.ElementNodes,
                                               'nodeCoords' : self.nodes,
                                               'connect2elem': self.ElementConnect2Elem,
                                               'connect2face': self.ElementConnect2Face})
                                      )
        self.faces = ProxyFaces(Face({'edgenos': self.FaceEdges,
                                      'nodes': self.FaceNodes,
                                      'nodeCoords': self.nodes,
                                      'connect2elem': self.FaceConnect2Elem})
                                )
        # eMAGUS doesn't provide face edge information
        self.faces.entity._edgenos = find_face_edges(self.faces, self.elements)
        self.edges = ProxyEdges(Edge({'nodes': self.EdgeNodes,
                                      'nodeCoords': self.nodes,
                                      'connect2elem': self.EdgeConnect2Elem},
                                     self.faces)
                                )
class MeshWithNodeElementConnections(MeshBase):
        def __init__(self, meshEntities):
            super(MeshWithNodeElementConnections, self).__init__(meshEntities)
            try:
                self.nodeElementConnections = self.makeNodeElementConnections(
                    meshEntities['NodeConnect2Element'],
                    meshEntities['NodeConnect2ElementPtr'])
            except KeyError:
                self.nodeElementConnections = None

        def makeNodeElementConnections(self, node2elem, node2elem_ptr):
            no_els = len(self.elements)
            no_nodes = len(self.nodes)
            assert(no_els*self.elements[:].COUNT.node == len(node2elem))
            return [
                node2elem[node_ptr:next_node_ptr]
                for node_ptr, next_node_ptr in
                zip(node2elem_ptr[0:no_nodes], node2elem_ptr[1:no_nodes+1])]
            
            
class MeshWithKDTree(MeshWithNodeElementConnections):
    @staticmethod 
    def edgeLengths(edges):
        return N.array(
            [N.linalg.norm(e.nodeCoords[0]-e.nodeCoords[1]) for e in edges])
    
    @property
    def maxEdgeLength(self):
        try: return self._maxEdgeLength
        except AttributeError:
            print "Calculating maximum edge length"
            self._maxEdgeLength = N.max(self.edgeLengths(self.edges))
        return self._maxEdgeLength
    
    @property
    def kdTree(self):
        try: return self._kdTree
        except AttributeError:
            from Bio.KDTree import KDTree
            print "Creating KDTree"
            self._kdTree = KDTree(dim=3)
            #self._kdTree.set_coords(Numeric.array(self.nodes.astype(N.float32)))
            self._kdTree.set_coords(self.nodes.astype(N.float32))

        return self._kdTree
    
    def findClosestNode(self, coord):
        nodeNos = self.findNodesRadius(coord, self.maxEdgeLength)
        return nodeNos[
            N.argmin([N.linalg.norm(coord-n) for n in self.nodes[nodeNos]])]
        
    def findNodesRadius(self, coord, radius):
        kdt = self.kdTree
        kdt.search(coord, radius)
        return kdt.get_indices() # Convert kdt's Numeric arrays to Numpy

class Mesh(MeshWithKDTree): pass


def find_face_edges(faces, elements):
    """
    Make a noFaces rows x 3 column array of face edges
    """
    FaceEdges = zeros((len(faces), 3), int32) - 1
    facedone = set()
    for el in elements:
        for i, face in enumerate(el.facenos):
            if face in facedone: continue
            FaceEdges[face] = el.edgenos[el.LOCAL_FACEEDGES[i]]
            facedone.add(face)

    assert(alltrue(alltrue(FaceEdges != -1)
                   )
           )
            
    return FaceEdges            
    

def MeshItemClassFactory(attrs, clsname, computed_attrs=('nodeCoords',)):
    """
    Generate a custom ProxyListItem class for use as a mesh entity

    Arguments
    =========

    attrs
      A list of attribute names for the proxied lists

    clsname
      The name of the generated class

    Returns
    =======

    A class called clsname that subclasses ProxyList.ProxyList behaviour with
    the addition of the calculated nodeCoords attribute.
    """
    
    ProxyListItem = ProxyList.ItemClassFactory(attrs, 'ProxyListItem' + clsname)

    class MeshItemClass(ProxyListItem):
        computedAttributes = computed_attrs
        @property
        def nodeCoords(self):
            """Return the space coordinates of the mesh entity's nodes"""
            return self._nodeCoords[self.nodes]

        def __init__(self, attrs=None, *names, **kwargs):
            # The nodeCoords list is not the same length as the others,
            # since the nodeCoords property returns a computed value
            for attr in self.computedAttributes:
                try:
                    setattr(self, '_'+attr, attrs[attr])
                    del attrs[attr]
                except KeyError: pass
                
            # Mesh objects allow some of the attrs to be undefined, but the
            # ProxyItem class not. 
            for key in attrs.keys():
                if attrs[key] is None:
                    del attrs[key]
                    setattr(self, '_'+key, None)
            super(MeshItemClass, self).__init__(attrs=attrs, *names, **kwargs)

    MeshItemClass.__name__ = clsname
    return MeshItemClass


class ProxyEntities(ProxyList.ProxyList):
    @property
    def nodemap(self):
        try: return self._nodemap
        except AttributeError: pass

        self._nodemap = nodemap = dict(
            (tuple(nds), i) for i, nds in enumerate(self[:].nodes))
        return nodemap

class BoundaryProxyEntities(ProxyEntities):
    """
    Add the onBoundary property to a geometrical entity proxy list.

    This makes entitylist.onBoundary return all the entities on the
    boundary. E.g. if entity no's [0,3,5] are on the boundary,
    entitylist[[0,3,5]] == entitylist.onBoundary. Depends on entity._onBoundary
    having been initialised.

    """
    @property
    def onBoundary(self):
        """
        Return all the entities on the boundary
        """
        self.entity.index=list(self.entity._onBoundary)
        return self.entity

    @property
    def boundarySet(self):
        return self.entity._onBoundary

class ProxyElements(ProxyEntities):
    pass

class ProxyFaces(BoundaryProxyEntities):
    pass

class ProxyEdges(BoundaryProxyEntities):
    pass

class BoundaryEntity(object):
    """
    Add entity.onBoundary property. 
    
    Depends on the the _onBoundary set having been initialised by the mixing
    class. It is expected to be a python set type containing the index of all
    the boundary edges.
    """
    proxy_attrs = ('onBoundary',) 
    @property
    def onBoundary(self):
        """
        Return True if the entity is on the boundary of the mesh, False otherwise
        """
        index = self.index
        if isscalar(index): return index in self._onBoundary
        # Check if we are dealing with a slice
        try: index = xrange(*index.indices(self.numberof))
        except AttributeError: pass
        
        return array([x in self._onBoundary for x in index])

    
ProxyEdge = MeshItemClassFactory(('nodes', 'nodeCoords', 'connect2elem'),
                                 'ProxyEdge')
ProxyEdge.meshtype = 'tet'
ProxyEdge.entity_type = 'edge'
class EdgeInit(object):
    def __init__(self, attrs, faces=None, *names, **kwargs):
        """
        Initialise proxy edges using the list mesh representation in attrs

        Boundary edges can be passed in the list representation as a python set
        containing the indices of all the edges on the boundary, and will be
        checked for first. Otherwise, faces must contain the  face list for the
        given mesh, and will be used to find the edges on the mesh boundary.
        """
        
        try:
            self._onBoundary = attrs['onBoundary']
            del attrs['onBoundary']
        except KeyError:
            onBoundary = set()
            # Find boundary edges by looping over the boundary faces
            if faces is not None:
                for faceedges in faces.onBoundary.edgenos:
                    for edge in faceedges:
                        onBoundary.add(edge)
                self._onBoundary = onBoundary
            
        super(EdgeInit, self).__init__(attrs=attrs, *names, **kwargs)
    

class Edge(EdgeInit, ProxyEdge, BoundaryEntity):
    proxy_attrs = ProxyEdge.proxy_attrs + BoundaryEntity.proxy_attrs

ProxyFace = MeshItemClassFactory(('edgenos', 'nodes', 'nodeCoords', 'connect2elem',),
                            'ProxyFace')
ProxyFace.meshtype = 'tet'
ProxyFace.entity_type = 'face'
class FaceArea(object):
    def area(self):
        a,b,c = self.nodeCoords
        ab = b - a
        ac = c - a
        return N.linalg.norm(scipy.cross(ab,ac))/2
    
class BoundaryFace(ProxyFace, BoundaryEntity):
    proxy_attrs = ProxyFace.proxy_attrs + BoundaryEntity.proxy_attrs

    def __init__(self, attrs, *names, **kwargs):
        """
        Initialise proxy faces using the list mesh representation in attrs

        Boundary faces can be passed in the list representation as a python set
        containing the indices of all the faces on the boundary, and will be
        checked for first. Otherwise, entites['connect2elem'] will be scanned
        to find the faces on the mesh boundary.
        """

        # Incase the onBoundary set has already been calculated
        try:
            self._onBoundary = attrs['onBoundary']
            del attrs['onBoundary']
        except KeyError: 
            connect2elem=attrs['connect2elem']
            # element2 is the global number of the second element that the face is
            # connected to. A value of -1 indicates no connection. Faces connected
            # to only one element have to be on the mesh boundary
            self._onBoundary = set(i for i, element2
                               in enumerate(connect2elem[:,1])
                               if element2 == -1)
        super(BoundaryFace, self).__init__(attrs=attrs, *names, **kwargs)
    

class Face(BoundaryFace, FaceArea): pass

ProxyElement = MeshItemClassFactory(('facenos', 'edgenos', 'nodes', 'nodeCoords',
                                     'connect2elem', 'connect2face'),
                                    'ProxyElement')

class Element(ProxyElement, Coordinates.SimplexCoord):
    """
    ProxyItemClass based tetrahedral mesh element class

    Inherits from Coordinates.SimplexCoord for coordinate calculations.
    Inherits from ProxyElement the attributes described below.

    Attributes
    ==========

    nodes
      The global node indices that define the element

    edgenos
      List of global edge indices of the element's six edges.

    facenos
      List of global face indices of the element's four edges.

    nodeCoords
      4-row x 3 col array containing the node coordinates      

    volume
      Volume of given element

      """

    meshtype = 'tet'
    # Maps an element local edge number to element local node numbers
    LOCAL_EDGENODES = array([[1,2],
                             [1,3],
                             [1,4],
                             [2,3],
                             [2,4],
                             [3,4]], int32) - 1

    # Maps an element local face number to element local node numbers
    LOCAL_FACENODES = array([[1,2,3],
                             [1,2,4],
                             [1,3,4],
                             [2,3,4]], int32) - 1
    # The "other" node not connected to face
    LOCAL_FACE_OPPOSING_NODE = array([4,3,2,1], int32) - 1
    # Which local faces is each edge connected to?
    LOCAL_EDGEFACES = array([[1,2],
                             [1,3],
                             [2,3],
                             [1,4],
                             [2,4],
                             [3,4]], int32) - 1

    # Maps an element local face number to element local edge number. Note that
    # the edge direction sense of the third face edge is negative
    LOCAL_FACEEDGES = array([[1,4,2],
                             [1,5,3],
                             [2,6,3],
                             [4,6,5]], int32) - 1
    COUNT=Struct(**{'node':4, 'edge': 6, 'face':4, 'vol':1})
    @property
    def volume(self):
        elc = self.nodeCoords
        matr = [elc[0]-elc[1], elc[1]-elc[2], elc[2]-elc[3]]
        return abs(linalg.det(matr))/6

    size = volume                       # Simplex size == volume in 3D

    @property
    def midpoint(self):
        return self.nodeCoords.sum(axis=-2)/4

    def outwardNormals(self):
        return N.array([-grd_lam/norm(grd_lam) for grd_lam
                        in self.GradLambda()[self.LOCAL_FACE_OPPOSING_NODE]],
                       N.float64)

    normals = outwardNormals
 
